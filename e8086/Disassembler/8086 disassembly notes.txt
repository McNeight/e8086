
8086 Instruction Notes

First byte:	bits 7-2 is the op code
			bit 1 is the direction, sign extension or carry info
			bit 0 is the operand word size flag
Second byte:	(addressing mode byte)
				bits 7-6 is the mode
				bits 5-3 is reg
				bits 2-0 is r/m
Bytes 3,4,5,6 are optional and little endian

----------------------------------------------------------------------------------
Direction Bit:
	d = 0:	data moved from operand specified by REG to operand specified by R/M
	d = 1:	data moved from operand specified by R/M to operand specified by REG

	s = 0:	two bytes of immediate data are present
	s = 1:	one byte of immediate data is present which is sign extended to 
			produce a 16 bit operand

	c = 0:	do not use CL for shift count
	c = 1:	use CL for shift count
----------------------------------------------------------------------------------
Operand word size flag
	w = 0:	data is a byte (8 bits)
	w = 1:	data is a word (16 or 32 bits depending on machine)
----------------------------------------------------------------------------------
Prefix Byte:
	Prior to the op code byte there may be a prefix instruction.  There are four types:
		1. Repetition
		2. Segment Overrides
		3. Lock
		4. Addr/Operand size overrides (for 32 bit machines)

	Repetition
		REP,REPE,REPZ		0xf3
		REPNE,REPNZ			0xf2

	Segment Override
		CS					0x2e
		DS					0x3e
		ES					0x26
		SS					0x36

	Lock					0xf0

	Addr/Oper Override
		0x66 = operand size override
		0x67 = address size override
		
	Addr/Oper Override Example
	Instruction				16-bit code		32-bit code
	mov ax,[bx]				8b 07			67 66 8b 07
	mov eax,[bx]			66 8b 07		67 8b 07
	mov ax,[ebx]			67 8b 03		66 8b 03
	mov eax,[ebx]			67 66 8b 03		8b 03
----------------------------------------------------------------------------------
Interpreting mode portion of address mode byte
	R/M Table 1 (when mode = 00)
	000	[BX+SI]			010 [BP+SI]			100 [SI]		110 Direct Addr
	001 [BX+DI]			011 [BP+DI]			101 [DI]		111 [BX]

Notes regarding mode=00 R/M=110
	Opcode	Addr Mode -or- Opcode AddrMode Offset-Low Offset-High
	mov ax,[2a45]
	mov ax,[di]
	
	R/M Table 2 Add displacement to register specified
	000	[BX+SI]			010 [BP+SI]			100 [SI]		110 [BP]
	001 [BX+DI]			011 [BP+DI]			101 [DI]		111 [BX]

	When mod = 01 use table 2 with 8 bit displacement
	When mod = 10 use table 2 with 16 bit displacement

	Examples for R/M Table 2 mod = 01
	All instructions have the form OpCode AddrMode Displacement
		mov ax,[bp+2]
		mov dx,[bx+di+4]
		mov [bx-4],ax

	Examples for R/M Table 2 mod = 10
		add ax,[bx+1000]

	When mod = 11 use the value of REG 
	Examples
		mov ax,[bx]
		mov dx,cx
		mov ah,bl

	REG		w=0	w=1		REG		w=0	w=1
	000		AL	AX		100		AH	SP
	001		CL	CX		101		CH	BP
	010		DL	DX		110		DH	SI
	011		BL	BX		111		BH	DI

Reg value is sometimes the segmentation register
	REG		Segment
	000		ES
	001		CS
	010		SS
	110		DS

Notes about the addressing mode byte:
	1. Usually not present if the instruction has no operands
	2. For one operand instructions the R/M field indicates where the operand is found
	3. For two operand instructions (except those with immediate) one is a register determined by REG
		and the other may be a register or memory specified by R/M
	4. Direction bit has meaning only for two operand instructions and indicates if the destination
		is specified by REG or R/M
----------------------------------------------------------------------------------
POP Encoding Examples.  POP op code is 0x8f

To POP into AX: 8f c0
	MOD = 11
	R/M = 000

To POP into BP: 8f c3
	MOD = 11
	R/M = 101

To POP into memory location DS:1200: 8f 06 00 12
	MOD = 00
	R/M = 110

To POP into memory location CS:1200: 2e 8f 06 00 12
----------------------------------------------------------------------------------
POP General Register
	pop ax		0x58
	pop bx		0x5b

POP Segment Register
	pop es		0x07
	pop ds		0x1f
	pop ss		0x17
----------------------------------------------------------------------------------
MOV instruction examples:  MOV reg/mem,reg/mem

	mov ax,bx		
		w=1 because these are words
		mod=11 because this is register to register

		if d=0 then src is REG (BX) and dst is R/M (AX)
			= 1000 1001	(0x89)
			= 1101 1000	(0xd8)

		if d=1 then src is REG (AX) and dst is R/M (AX)
			= 1000 1011 (0x8b)
			= 1010 0011 (0xc3)

	mov [bx+10],CL = 88 4f 10
		w=0 because this is a byte
		d=0 because need R/M table 2 to encode [bx+10]
		mod=01, reg=001 and r/m=111

	mov [bx+10],cx = 89 4f 10

	mov [bx+10],CL with 16 bit displacement: 88 8f 10 00
----------------------------------------------------------------------------------
MOV reg/mem,immediate
	




	




